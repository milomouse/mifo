#!/bin/zsh
#############################################################################
# author: milomouse <vincent[at]fea.st>   |   updated: 2013-02-03 15:46:39  #
##NOTE:######################################################################
# Command a daemonized MPlayer with preset or native commands sent via FIFO #
# MPlayer keys are disabled; this means you must seek (etc.) with -c option #
# and/or bind commands to keys for faster media navigation (e.g. xbindkeys) #
# ------------------------------------------------------------------------- #
#    1] zsh  2] mplayer  3] procps(ps|pgrep|pkill)  4] coreutils(mkfifo)    #
#############################################################################
# contains Zsh shorthand and nested expansions; not recommended for porting #
#############################################################################

## DO NOT CHANGE THESE OPTIONS:
setopt extendedglob nomultios noshfileexpansion nonomatch
exec 6>/dev/null

## start of FUNCTIONS {{{

# catch SIGINT and prompt for daemon closure:
function TRAPINT {
  unset X
  print "\nCaught SIGINT"
  while { true } {
    integer X=$(( ${X:-6} - 1 ))
    [[ ${X} -le 0 ]] && break
    printf "(${X}) Kill daemon? [y/N]: "
    read -t 1 -k 1 o
    if [[ $o:l == y ]] {
      printf '\r%s'";; Closing Daemon"
      print ${$(print "(x) Kill daemon? [y/N]: ")//[[:graph:][:punct:]]/ }
      i_quit 1
      break
    } elif [[ -z $o ]] { printf '\r%s'
    } elif [[ -n $o && $o:l != y  ]] {
      printf '\r%s'";; Aborting"
      print ${$(print "(x) Kill daemon? [y/N]: ")//[[:graph:][:punct:]]/ }
      break
  };}
  return $(( 128 + $1 ))
}

# check existence of setting locations, attempt to create if not found:
function d_fileprobe {
  zmodload -F zsh/files +b:mkdir >&- 2>&6
  if [[ ! -d ${file[base]} ]] {
    mkdir -p "${file[base]}" >&- 2>&6 || {
      printf ";; Cannot create ${file[base]}," ; file[base]=/tmp/mifo-${USER}
      print " using ${file[base]}" ; mkdir -p ${file[base]} >&- 2>&6 }
    if [[ ! -d ${file[base]} ]] {
      o_err ";; Cannot create ${file[base]}, aborting"
    }
  }
  if [[ ! -d ${file[pgrp]:h} ]] {
    mkdir -p "${file[pgrp]:h}" >&- 2>&6 || {
      printf ";; Cannot create ${file[pgrp]:h}," ; file[pgrp]=/tmp/mifo-${USER}.pid
      print " using ${file[pgrp]:h}" ; mkdir -p ${file[pgrp]:h} >&- 2>&6 }
    if [[ ! -d ${file[pgrp]:h} ]] {
      o_err ";; Cannot create ${file[pgrp]:h}, aborting"
    }
  }
  [[ ! -d ${file[base]}/playlists ]] && {
    mkdir -p "${file[base]}"/playlists >&- 2>&6 || o_err ";; Cannot create ${file[base]}/playlists, aborting" }
  zmodload -F zsh/files -b:mkdir >&- 2>&6
  [[ ! -p ${file[fifo]} ]] && { rm -f "${file[fifo]}" >&- 2>&6 ; mkfifo "${file[fifo]}" || o_err ";; Cannot create ${file[fifo]}, aborting" }
  [[ ! -f ${file[stat]} ]] && { : > "${file[stat]}" >&- 2>&6 || o_err ";; Cannot create ${file[stat]}, aborting" }
  [[ ! -f ${file[play]} ]] && { : > "${file[play]}" >&- 2>&6 || o_err ";; Cannot create ${file[play]}, aborting" }
  [[ ! -f ${file[fave]} ]] && { : > "${file[fave]}" >&- 2>&6 || o_err ";; Cannot create ${file[fave]}, aborting" }
}

# check if playlist found within playlist directory and print if true:
function d_playlist {
  if [[ -f ${file[base]}/playlists/${@%.m3u}.m3u ]] {
    PL=${file[base]}/playlists/${@%.m3u}.m3u ; return 0
  } elif [[ ${@:u} == ${file[play]:t} ]] {
    return 2
  } elif [[ -f ${@} && ${@:h} == ${file[base]}/playlists ]] {
    if [[ ${@} != ${file[play]} ]] {
      PL=${@} ; return 0
    } else { return 2 }
  } elif [[ -f ${@:a} && ${@:a:h} == ${file[base]}/playlists ]] {
    if [[ ${@:a} != ${file[play]} ]] {
      PL=${@:a} ; return 0
    } else { return 2 }
  } else { return 1
};}

# contain daemon command until needed:
function d_daemon {
  ## DO NOT CHANGE mplayer COMMAND UNLESS YOU KNOW EXACTLY WHAT YOU'RE DOING:
  _daemon=(mplayer -slave -idle -quiet -msgmodule -msglevel all=0:global=4:cplayer=4 \
-gapless-audio -nocache -novideo -nosub -noconsolecontrols \
-input nodefault-bindings:conf=/dev/null:file=${file[fifo]} -include ${file[conf]})
}

# check if daemon is running or not:
function d_instance {
  d_daemon
  ps -C mplayer -o pgrp=,args= | while { read i } {
    if [[ -s ${file[pgrp]} ]] {
      if [[ ${${(s. .)i}[1]} == $(<${file[pgrp]}) ]] { I=${${(s. .)i}[1]} }
    } else {
      if [[ ${#${(f)${(s. .)i}[2,$]}#${${_daemon}}} -eq 0 ]] { I=${${(s. .)i}[1]} }
};};}

# check pid file validity and accompanying daemon instance:
function d_purge {
  zmodload -F zsh/files +b:rm >&- 2>&6
  d_instance
  if [[ -f ${file[pgrp]} ]] {
    if [[ ${+I} -eq 1 ]] {
      if [[ ! -p ${file[fifo]} ]] { mkfifo ${file[fifo]} }
      if [[ ! -s ${file[pgrp]} ]] { d_pgrp ${I} }
    } else {
      rm -f ${file[pgrp]} ${file[fifo]} >&- 2>&6
      return 1
    }
  } else {
    if [[ ${+I} -eq 1 ]] {
      d_fileprobe
      d_pgrp ${I}
    } else { rm -f ${file[fifo]} >&- 2>&6 }
  }
  zmodload -F zsh/files -b:rm >&- 2>&6
}

# re/create pid file:
function d_pgrp {
  if [[ $1 == <-> ]] {
    #until [[ -s ${file[pgrp]} && $(<${file[pgrp]}) == <-> ]]; do
      print $1 >! ${file[pgrp]}
    #done
  } else {
    d_daemon
    until [[ -s ${file[pgrp]} && $(<${file[pgrp]}) == <-> ]]; do
      local x y
      x=$(pgrep -f "${_daemon}" 2>&6)
      y=$(ps --pid ${x} hopgrp 2>&6)
      if [[ -n ${y} ]] {
        print - ${y# } >! ${file[pgrp]}
        break
      } else { sleep 1s }
    done
};}

# send [output];$? if daemon is running or not:
function i_active {
  if [[ $1:l == -- ]] {
    << EOP
example:

  ((daemon NOT running))

arguments:

  ((no arg)) = display (active|inactive) and return exit code (0|1)

usage:

  % mifo --instance
  inactive

EOP
    return 0
  }
  d_instance
  I=${${I:+active}:-inactive}
  print $I
  if [[ $I == active ]] { return 0 } else { return 1 }
}

# run daemon if necessary:
function i_daemon {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = start daemon if not running, else check/fix PID

EOP
    return 0
  }
  d_instance
  if [[ ${+I} -eq 1 ]] {
    if [[ ! -f ${file[pgrp]} || ! -s ${file[pgrp]} ]] {
      d_pgrp ${I}
    }
    return 1
  }
  d_purge
  d_fileprobe
  if [[ ! -s ${file[pgrp]} ]] {
    ${_daemon} >>&| ${file[stat]} &
    d_pgrp
  }
  exit
}

# close daemon permanetly:
function i_quit {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = cause daemon to be inactive (e.g. kill)
  (integer) = cause daemon to be inactive using exit code (integer)

EOP
    return 0
  }
  d_instance
  if [[ -p ${file[fifo]} && ${+I} -eq 1 && -s ${file[pgrp]} ]] {
    print get_time_pos >> ${file[fifo]}
    if [[ $1 == <-> ]] {
      print "quit ${1}" >> ${file[fifo]} &
    } else {
      print quit >> ${file[fifo]} &
  };}
  if [[ ${+I} -eq 1 ]] { pkill -g ${I} >&- 2>&6 }
  zmodload -F zsh/files +b:rm >&- 2>&6
  rm -f ${file[pgrp]} ${file[fifo]} >&- 2>&6
  zmodload -F zsh/files -b:rm >&- 2>&6
  if [[ $1 == <-> ]] { return $1 } else { return 0 }
}

# close daemon temporarily:
function i_stop {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = stop playback while keeping daemon active (e.g. idle)

EOP
    return 0
  }
  d_purge
  if [[ ${+I} -eq 0 ]] { return 1 }
  print get_time_pos >> ${file[fifo]}
  print stop >> ${file[fifo]} &
}

# validate file(s) and dir(s):
function i_load {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = do nothing
  (file) = if valid load files and begin playback
  (directory) = probe directory for files and if valid load files
  (playlist) = probe playlist for files and if valid load files
  (file|directory|playlist) = check each accordingly

usage:

  % mifo --load directory1/fileX directory2 ./fileX
  % mifo --load ~/fileX
  % mifo --load /directory/fileX
  % mifo --load ../directory/fileX

notes:

  1) Playlists must be one-file-per-line and have the .m3u extension!
  2) Your shell determines how arguments are sent to the daemon, e.g.:
       "directory/file[1,3].x"
     may interpret to:
       "directory/file1.x directory/file3.x"
     in some shells and not others, so understand your shell.

EOP
    return 0
  } elif [[ $1:l == "${$}.append" && $2:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = do nothing
  (file) = if valid load files and keep playback on current file
  (directory) = probe directory for files and if valid load files
  (playlist) = probe playlist for files and if valid load files
  (file|directory|playlist) = check each accordingly

usage:

  % mifo --append directory1/fileX directory2 ./fileX
  % mifo --append ~/fileX
  % mifo --append /directory/fileX
  % mifo --append ../directory/fileX

notes:

  1) Playlists must be one-file-per-line and have the .m3u extension!
  2) Your shell determines how arguments are sent to the daemon, e.g.:
       "directory/file[1,3].x"
     may interpret to:
       "directory/file1.x directory/file3.x"
     in some shells and not others, so understand your shell.

EOP
    return 0
  }
  d_purge
  if [[ ${+I} -eq 0 ]] { return 1 }
  unset _start
  if [[ -n $1 ]] {
    print -C1 "$@" "${$}.stop" | while { read x } {
      if [[ -f $x:a && -s $x:a ]] { i_load_file $x:a
      } elif [[ -d $x:a ]] { i_load_dir $x:a
      } elif [[ $x == "${$}.stop" ]] { i_load_file $x
      } elif [[ $x == "${$}.append" ]] { i_load_file $x
};};};}

# locate file(s) within dir(s):
function i_load_dir {
  print -C1 $1:a/* | while { read d } {
    if [[ -f $d ]] { i_load_file $d
    } elif [[ -d $d ]] { i_load_dir $d
};};}

# load file(s) as well as file(s) within playlist(s):
# playlist(s) must be one-file-per-line with .m3u file extension
function i_load_file {
  if [[ $1:a:e == m3u ]] {
    < $1:a | while { read p } {
      if [[ $1:a == $p:a ]] { break } \
      if [[ -f $p:a && -s $p:a ]] { i_load_file $p:a };}
  } else {
    if [[ $1 == "${$}.stop" && ${_start} -eq 1 ]] {
      : >! ${file[stat]}
      print "loadlist ${file[play]}" >> ${file[fifo]}
    } elif [[ $1 == "${$}.append" && ${+_start} -eq 0 ]] { _start=1
    } elif [[ $1 == "${$}.append" && ${+_start} -eq 1 ]] { break
    } else {
      if [[ ${+_start} -eq 0 ]] { _start=1 ; : >! ${file[play]} }
      print - "$1" >>! ${file[play]}
};};}

# load current playlist from a given position:
function i_begin {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = reload current playlist from beginning
  list = reload current playlist from beginning
  song = reload current playlist from current song
  last = reload current playlist from last position
  0 = ((same as list))
  1 = ((same as song))
  2 = ((same as last))

EOP
    return 0
  }
  d_purge
  if [[ ${+I} -eq 0 ]] { return 1 }
  if [[ -n $1 ]] {
    case $1:l {
      '0'|'list')
        : >! ${file[stat]} 2>&6
        print "loadlist ${file[play]}" >> ${file[fifo]}
      ;;
      '1'|'song'|'2'|'last')
        local n c s
        n=${${${(@f)${${(F)"$(<${file[stat]})"}/*[[:cntrl:]]Playing }}[1]}%.}
        if [[ ${(c)#n} -le 1 ]] { integer c=1
        #} else { c=${(fw)#${(@F)"$(<${file[play]})"}%${n#/}*} }
        } else { <${file[play]} | while { read x } { integer c=$((${c:-0}+1)) ; if [[ ${n} == ${x} ]] { break };} }
        print "loadlist ${file[play]}" >> ${file[fifo]}
        if [[ ${c} -eq 1 ]] { print "seek 0 1" >> ${file[fifo]}
        } else { print "pt_step +$(( ${c} - 1 ))" >> ${file[fifo]} }
        if [[ $1 == 2 || $1:l == last ]] {
          s=${${(@f)${(F)${(F)"$(<${file[stat]})"}/*ANS_TIME_POSITION=}}[1]}
          if [[ ${(c)#s} -eq 1 ]] {
            s=${${(f)${(F)"$(<${file[stat]})"}/*ANS_TIME_POSITION=}[1]}
          } elif [[ ${s} != <->.<-> ]] { s=${${(f)s}[1]} }
          if [[ ${s} == <-> || ${s} == <->.<-> ]] { print "seek ${s} 2 1" >> ${file[fifo]} }
        }
      ;;
    }
  } else { print "loadlist ${file[play]}" >> ${file[fifo]}
};}

# toggle playback:
function i_toggle {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = toggle between pause/unpause depending on current state
  unpause = unpause playback
  pause = pause playback
  0 = ((same as unpause))
  1 = ((same as pause))

EOP
    return 0
  }
  d_purge
  if [[ ${+I} -eq 0 ]] { return 1 }
  if [[ -n $1 ]] {
    case $1 {
      '0'|'unpause') print "set_property pause off" >> ${file[fifo]} ;;
      '1'|'pause') print "set_property pause on" >> ${file[fifo]} ;;
    }
  } else {
    if [[ ${$(<${file[stat]})[-1]/(Team|\(Quit\))/CPLAYER:} == CPLAYER: ]] {
      print "set_property pause off" >> ${file[fifo]}
      i_begin last
    } else { print pause >> ${file[fifo]}
};};}

# move forward in current playlist:
function i_next {
  if [[ $1:l == -- ]] {
    << EOP
example:

  "/home/user/music/artist/album/01_earth.mp3"
  "/home/user/music/artist/album/02_wind.mp3"
  "/home/user/music/artist/album/03_water.mp3" <(playing)
  "/home/user/music/artist/album/04_fire.mp3"
  "/home/user/music/artist/album/05_earthquake.mp3"

arguments:

  ((no arg)) = move forward in playlist by 1
  (integer) = move forward in playlist by (integer)
  (keyword) = move forward in playlist to first occurance of (keyword)

usage:

  % mifo --next 2
  % mifo --next earth

EOP
    return 0
  }
  d_purge
  if [[ ${+I} -eq 0 ]] { return 1 }
  if [[ -n $1 ]] {
    if [[ $@ == 0 ]] { print "seek 0 1" >> ${file[fifo]} ; return 0 }
    local n c x y
    n=${${${(@f)${${(F)"$(<${file[stat]})"}/*[[:cntrl:]]Playing }}[1]}%.}
    <${file[play]} | while { read x } { integer c=$((${c:-0}+1)) ; if [[ ${n} == ${x} ]] { break };}
    if [[ ${@//+} == <-> ]] {
      integer C=${#${(@f)"$(<${file[play]})"}}
      if [[ $(( ${C} - ${c} )) -ge ${1//+} ]] {
        print "pt_step +${1//+}" >> ${file[fifo]}
      }
      return 0
    } else {
      <${file[play]} | while { read i } {
        if [[ $i == $n ]] {
          integer C=0
        } elif [[ ${+C} -eq 1 ]] {
          integer C=$(( ${C} + 1 ))
          if [[ ${#i/$@} != ${#i} ]] {
            print "pt_step +${C}" >> ${file[fifo]} ; break }
    };};}
  } else {
    print "pt_step +1" >> ${file[fifo]}
};}

# move backward in current playlist:
function i_prev {
  if [[ $1:l == -- ]] {
    << EOP
example:

  "/home/user/music/artist/album/01_earth.mp3"
  "/home/user/music/artist/album/02_wind.mp3"
  "/home/user/music/artist/album/03_water.mp3" <(playing)
  "/home/user/music/artist/album/04_fire.mp3"
  "/home/user/music/artist/album/05_earthquake.mp3"

arguments:

  ((no arg)) = move backward in playlist by 1
  (integer) = move backward in playlist by (integer)
  (keyword) = move backward in playlist to first occurance of (keyword)

usage:

  % mifo --prev 2
  % mifo --prev earth
  (/home/use/music/artist/album/01_earth.mp3)

EOP
    return 0
  }
  d_purge
  if [[ ${+I} -eq 0 ]] { return 1 }
  if [[ -n $1 ]] {
    if [[ $@ == 0 ]] { print "seek 0 1" >> ${file[fifo]} ; return 0 }
    local n c x y
    n=${${${(@f)${${(F)"$(<${file[stat]})"}/*[[:cntrl:]]Playing }}[1]}%.}
    <${file[play]} | while { read x } { integer c=$((${c:-0}+1)) ; if [[ ${n} == ${x} ]] { break };}
    if [[ ${@//[-+]} == <-> ]] {
      integer C=${#${(@f)"$(<${file[play]})"}}
      if [[ $(( ${C} - ${1//[-+]} )) -le ${c} ]] {
        print "pt_step -${1//[-+]}" >> ${file[fifo]}
      }
      return 0
    } else {
      <${file[play]} | while { read i } {
        if [[ $i == $n ]] { return 1
        } else {
          if [[ ${+C} -eq 0 ]] {
            integer C=$(( ${c} - 1 ))
          } else { integer C=$(( ${C} - 1 )) }
          if [[ ${#i/$@} != ${#i} ]] {
            print "pt_step -${C}" >> ${file[fifo]} ; break }
    };};}
  } else {
    print "pt_step -1" >> ${file[fifo]}
};}

# repeat current file X amount of times, indefinitely or none; or toggle:
function i_repeat {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = toggle between repeat ON/OFF
  (integer) = repeat current file (integer) times
  on = repeat current file indefinitely
  off = do not repeat the current file
  yes = ((same as on))
  no = ((same as off))

notes:

  1) If repeat is already 'on' and you tell it to be 'on' again
     MPlayer will start to add each 'on' as (integer), e.g.: if
     you send 'repeat on' once it will be indefinite but if you
     send another 'repeat on' it will repeat the file 2 times,
     and another 'repeat on' will result in the file repeating
     3 times and so on, and like (integer) once it runs out the
     file will no longer be repeated.
  2) If you are unsure if the file is already being repeated,
     it is probably better to just use 'repeat' without args to
     toggle the state, else 'repeat off' then 'repeat on'. Also
     you may send command (-c) "get_property loop" and check
     the end of the mifo log file to see the value of ANS_loop
        <0 means no loop
         0 means loop indefinitely
        >0 means loop (X) times
     Do note that sometimes there is a delay in "get_property"
     and you might have to send the command twice and check the
     last result for better accuracy. e.g. (in Zsh):
        % repeat 2 { mifo -c "get_property loop" ; sleep 1s }

EOP
    return 0
  }
  d_purge
  if [[ ${+I} -eq 0 ]] { return 1 }
  if [[ -n $1 ]] {
    if [[ $1 == <-> ]] {
      print "loop ${1}" >> ${file[fifo]}
    } elif [[ $1 == "off" || $1 == "no" ]] { print "loop -1" >> ${file[fifo]}
    } elif [[ $1 == "on" || $1 == "yes" ]] { print "loop 1" >> ${file[fifo]}
    }
  } else {
    local l
    repeat 2 { print "get_property loop" >> ${file[fifo]} }
    { sleep 2s
      l=${$(<${file[stat]})[-1]#ANS_loop=}
      if [[ ${l} -ge 0 ]] { print "loop -1" >> ${file[fifo]}
      } elif [[ ${l} -lt 0 ]] { print "loop 1" >> ${file[fifo]} };} &
};}

# skip to a random file in current playlist:
function i_random {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = skip to a random file within current playlist

EOP
    return 0
  }
  d_purge
  if [[ ${+I} -eq 0 ]] { return 1 }
  local n c l L
  L=${#${(@f)"$(<${file[play]})"}}
  l=${(c)#${L}}
  until [[ ${eq} -lt ${L} && ${eq} -gt 0 ]] { eq=${RANDOM[0,-${l}]} }
    n=${${${(@f)${${(F)"$(<${file[stat]})"}/*[[:cntrl:]]Playing }}[1]}%.}
    <${file[play]} | while { read x } { integer c=$((${c:-0}+1)) ; if [[ ${n} == ${x} ]] { break };}
  if [[ ${eq} -gt ${c} ]] {
    print "pt_step +${$(( ${c} - ${eq} ))#-}" >> ${file[fifo]}
  } else {
    print "pt_step -${$(( ${eq} - ${c} ))#-}" >> ${file[fifo]}
};}

# load a saved playlist:
function i_playlist {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = do nothing
  (playlist) = load the saved playlist from \${file[base]}/playlists

EOP
    return 0
  }
  d_playlist $@
  if [[ $? -eq 0 || $? -eq 2 ]] { i_load ${PL} }
}

# check if current file is found within a playlist:
function i_check {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = display if current file exists within ${file[fave]:t}
  (playlist) = display if current file exists with the saved playlist

EOP
    return 0
  }
  n=${${${(@f)${${(F)"$(<${file[stat]})"}/*[[:cntrl:]]Playing }}[1]}%.}
  if [[ -n $1 ]] {
    d_playlist $@
    if [[ $? -eq 0 ]] {
      <$PL | while { read i } {
        if [[ ${n} == ${i} ]] {
          print found
          return 0
        }
      }
    } else { return 1 }
  } else {
    unset PL
    <${file[fave]} | while { read i } {
      if [[ ${n} == ${i} ]] {
        PL=${file[fave]}
        break
      }
    }
    if [[ ${+PL} -eq 1 ]] {
      print found
      return 0
    } else { return 1
};};}

# add current file to a playlist, else add to ${file[fave]}:
function i_add {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = add current file to ${file[fave]:t}
  (arg) = add current file to new playlist named (arg)
  (playlist)= add current file to a saved (playlist)

EOP
    return 0
  }
  local n
  n=${${${(@f)${${(F)"$(<${file[stat]})"}/*[[:cntrl:]]Playing }}[1]}%.}
  if [[ -n $1 ]] {
    d_playlist $@
    if [[ $? -eq 0 ]] {
      if [[ ${PL} == ${file[play]} ]] {
        return 1
      } else { print "${n}" >>! ${PL} }
    } else { print "${n}" >>! ${file[base]}/playlists/${${@:t}%.m3u}.m3u }
  } else { print "${n}" >>! ${file[fave]}
};}

# try to remove current file from a playlist, else try ${file[fave]}:
function i_remove {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = remove current file from ${file[fave]:t}
  (playlist) = remove current file from playlist

EOP
    return 0
  }
  i_check $@ 1>&6
  if [[ $? -eq 0 ]] {
    local N
    <${PL} | while { read i } {
      if [[ ${n} != ${i} ]] {
        if [[ -n ${N} ]] {
          N="${N}\\n${i}"
        } else {
          N="${i}"
    };};}
    print "$N" >! ${PL}
    return 0
  } else { return 1
};}

# save current playlist as a new playlist:
function i_save {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = display prompt for saving playlist as new
  (arg) = save current playlist as new playlist named (arg)

EOP
    return 0
  }
  if [[ -z $1 ]] {
    printf "Save playlist as: "
    read answer
    if [[ -n $answer && ${${answer:l}%.m3u} == ${file[play]:t:l} ]] {
      o_err ";; Playlist name \"${file[play]:t}\" is reserved, aborting"
    } elif [[ -z ${answer%.m3u} ]] {
      print ";; Aborting"
      return 0
    } else {
      <${file[play]} >! ${file[base]}/playlists/${answer%.m3u}.m3u
      return 0 }
  } else {
    if [[ ${${@:l}%.m3u} == ${file[play]:t:l} ]] {
      o_err ";; Playlist name \"${file[play]:t}\" is reserved, aborting"
    } else {
      <${file[play]} >! ${file[base]}/playlists/${@%.m3u}.m3u
      return 0
};};}

# edit a playlist:
function i_edit {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = display prompt for editing playlist
  (arg) = edit a saved playlist named (arg)

EOP
    return 0
  }
  if [[ -z $1 ]] {
    print playlists:\\n
    for i ( ${file[base]}/playlists/{${file[play]:t},*.m3u} ) {
      print -C1 "  "${i:t} }
    printf "\nEnter name: "
    read answer
    if [[ -z ${answer%.m3u} || ${answer:l} == q || ${answer:l} == quit ]] {
      print ";; Aborting"
      return 0
    } else {
      d_playlist ${answer}
      if [[ $? -eq 0 || $? -eq 2 ]] {
        if [[ ${+EDITOR} -eq 1 ]] {
          ${EDITOR:-vim} ${PL:-${file[play]}}
        } else { o_err ";; \$EDITOR environment variable not set, aborting." }
      }
    }
  } else {
    d_playlist $@
    if [[ $? -eq 0 || $? -eq 2 ]] {
      if [[ ${+EDITOR} -eq 1 ]] {
        ${EDITOR:-vim} ${PL:-${file[play]}}
      } else { o_err ";; \$EDITOR environment variable not set, aborting."
};};};}

# send preset/native commands to MPlayer:
function i_command {
  if [[ -z $1 ]] { return 1 }
  case $1:l {
    'load') { i_load ${@:/$1} } ;;
    'append') { i_load "${$}.append" ${@:/$1} "${$}.append" } ;;
    'playlist') { i_playlist ${@:/$1} } ;;
    'begin') { i_begin ${@:/$1} } ;;
    'toggle') { i_toggle ${@:/$1} } ;;
    'pause'|'unpause') { i_toggle ${1} } ;;
    'next') { i_next ${@:/$1} } ;;
    'prev'|'previous') { i_prev ${@:/$1} } ;;
    'repeat') { i_repeat ${@:/$1} } ;;
    'random') { i_random ${2} } ;;
    'stop') { i_stop ${2} } ;;
    'announce') { o_announce ${@:/$1} } ;;
    'show') { o_show ${@:/$1} } ;;
    'shown') { o_shown ${@:/$1} } ;;
    'help') { o_help } ;;
    'add') { i_add ${@:/$1} } ;;
    'remove') { i_remove ${@:/$1} } always { unset n PL } ;;
    'check') { i_check ${@:/$1} } always { unset n PL } ;;
    'save') { i_save ${@:/$1} } ;;
    'edit') { i_edit ${@:/$1} } always { unset PL } ;;
    'playlist') { i_playlist ${@:/$1} } always { unset PL } ;;
    'instance'|'active'|'activity') { i_active ${2} } ;;
    'quit') { i_quit ${@:/$1} } ;;
    'init') { i_daemon ${2} } ;;
    'mute'|'unmute')
      if [[ -n $2 ]] {
        case $2:l {
          '0'|'off'|'no') print "mute 0" >> ${file[fifo]} ;;
          '1'|'on'|'yes') print "mute 1" >> ${file[fifo]} ;;
        }
      } else { print "mute" >> ${file[fifo]} }
    ;;
    'fs'|'full'|'fullscreen')
      if [[ -n $2 ]] {
        case $2:l {
          '0'|'off'|'no') print "vo_fullscreen 0" >> ${file[fifo]} ;;
          '1'|'on'|'yes') print "vo_fullscreen 1" >> ${file[fifo]} ;;
          '2'|'toggle') print vo_fullscreen >> ${file[fifo]} ;;
        }
      } else { print "vo_fullscreen ${@:/$1}" >> ${file[fifo]} }
    ;;
    'command'|'-c'|'--command') { : } ;;
    *) { print - "$@" >> ${file[fifo]} } ;;
  }
}

# display current file with optional output format:
function o_announce {
  if [[ ! -f ${file[stat]} ]] { return 1 }
  #d_purge
  #if [[ ${+I} -eq 0 ]] { print "daemon is out of reach.. et quietus.." ; return 1 }
  if [[ $1:l == -- ]] {
    n="/home/user/music/artist/album/track name.mp3"
    << EOP
example:

  "${n}"

arguments:

  %a = ${n}
  %A = ${n:r}
  %b = ${n:t}
  %B = ${n:t:r}
  %c = ((track position))
  %C = ((playlist count))
  %d = ${n:h}
  %D = ${n:h:t}
  %e = ${n:e}

usage:

  % mifo --announce '%D / %B (%e)'
  ${n:h:t} / ${n:t:r} (${n:e})

EOP
    return 0
  }
  #%d:2 = ${n:h:h}
  #%D:2 = ${${n:h:h}:t}
  local n
  n=${${(F)"$(<${file[stat]})"}/*[[:cntrl:]]Playing }
  if [[ ${(fw)#n} -gt 1 ]] { n=${${(fw)n}[1]%.} } else { n=${n%.} }
  if [[ ${n[1]} != '/' ]] { print "daemon is out of reach.. et quietus.." ; return 1 }
  if [[ -n $1 ]] {
    if [[ ${#${(F)@}} == ${#${(F)@//\%[aAbBcCdDe]}} ]] { return 1 }
    local N x y
    if [[ ${#${(F)@}} != ${#${(F)@//\%a}} ]] { N=${${N:-$@}//\%a/${n}} }
    if [[ ${#${(F)@}} != ${#${(F)@//\%A}} ]] { N=${${N:-$@}//\%A/${n:r}} }
    if [[ ${#${(F)@}} != ${#${(F)@//\%b}} ]] { N=${${N:-$@}//\%b/${n:t}} }
    if [[ ${#${(F)@}} != ${#${(F)@//\%B}} ]] { N=${${N:-$@}//\%B/${n:t:r}} }
    if [[ ${#${(F)@}} != ${#${(F)@//\%c}} ]] {
      unset y
      <${file[play]} | while { read x } { integer y=$((${y:-0}+1)) ; if [[ ${n} == ${x} ]] { break };}
      N=${${N:-$@}//\%c/${y}} }
    if [[ ${#${(F)@}} != ${#${(F)@//\%C}} ]] {
      unset y
      y=${#${(@f)"$(<${file[play]})"}}
      N=${${N:-$@}//\%C/${y}} }
    if [[ ${#${(F)@}} != ${#${(F)@//\%d}} ]] { N=${${N:-$@}//\%d/${n:h}} }
    if [[ ${#${(F)@}} != ${#${(F)@//\%D}} ]] { N=${${N:-$@}//\%D/${n:h:t}} }
    if [[ ${#${(F)@}} != ${#${(F)@//\%e}} ]] { N=${${N:-$@}//\%e/${n:e}} }
    print - ${N}
  } else {
    print - ${n}
};}

# display saved playlists:
function o_printp {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = display saved playlists one-playlist-per-line

EOP
    return 0
  }
  for i ( ${file[base]}/playlists/* ) {
    if [[ $i != ${file[play]} && $i:e == m3u ]] { print - "${i}" }
  }
}

# display contents a playlist:
function o_show {
  if [[ ! -f ${file[stat]} ]] { return 1 }
  if [[ $1:l == -- ]] {
    print playlists:\\n
    o_printp | while { read i } {
      print -C2 "  "${i:t} \(${#${(@f)"$(<${i})"}}\) }
    << EOP

arguments:

  ((no arg)) = displays content of CURRENT
  (playlist)= displays content of (playlist).m3u

EOP
    return 0
  }
  if [[ ! -d ${file[base]}/playlists || ! -s ${file[play]} ]] { return 1 }
  if [[ -z $1 ]] { <${file[play]}
  } else {
    d_playlist $@
    if [[ $? -eq 0 || $? -eq 2 ]] { <${PL:-${file[play]}} }
};}

# display contents a playlist with relative position count:
function o_shown {
  if [[ ! -f ${file[stat]} ]] { return 1 }
  if [[ $1:l == -- ]] {
    if [[ -d ${file[base]}/playlists ]] {
    print playlists:\\n
    o_printp | while { read i } {
      print -C2 "  "${i:t} \(${#${(@f)"$(<${i})"}}\) }
    }
    << EOP

arguments:

  ((no arg)) = displays CURRENT with relative position
  (playlist) = displays content of (playlist).m3u with count

EOP
    return 0
  }
  if [[ ! -d ${file[base]}/playlists || ! -s ${file[play]} ]] { return 1 }
  local n c C S SN x y
  n=${${${(@f)${${(F)"$(<${file[stat]})"}/*[[:cntrl:]]Playing }}[1]}%.}
  <${file[play]} | while { read x } { integer c=$((${c:-0}+1)) ; if [[ ${n} == ${x} ]] { break };}
  C=$c
  if [[ ${@%.m3u} == ${${file[play]%.m3u}:t} || -z $1 ]] {
    if (! o_announce 1>&6) {
      <${file[play]} | while { read i } {
        integer SN=$(( ${SN:-0} + 1 ))
        print "${SN}  ${i}"
      }
    } else {
      unset op
      <${file[play]} | while { read i } {
        if [[ $i == $n ]] {
          unset SN op ; SN=0 ; op='+'
          [[ ${+S} == 1 ]] && print "${S:+${S}\\n} 0  ${i}"
        } else {
          if [[ $op == '+' ]] {
            integer SN=$(( ${SN:-0} ${op} 1 ))
            [[ ${+S} == 1 ]] && print "${S:+${S}\\n}${op}${SN}  ${i}"
          } else {
            op='-'
            integer C=$(( ${C} - 1 )) ; SN=$C
            [[ ${+S} == 1 ]] && print "${S:+${S}\\n}-${SN}  ${i}"
      };};}
      unset SN
    }
  } else {
    d_playlist $@
    if [[ $? -eq 0 || $? -eq 2 ]] {
      unset SN
      <${PL:-${file[play]}} | while { read i } {
        integer SN=$(( ${SN:-0} + 1 ))
        print "$SN  $i" }
      unset SN }
};}

# display current playlist, matching arg:
function o_match {
  if [[ ! -f ${file[stat]} ]] { return 1 }
  if [[ $1:l == -- ]] {
 << EOP
example:

  "/home/user/music/artist/album/01_earth.mp3"
  "/home/user/music/artist/album/02_wind.mp3"
  "/home/user/music/artist/album/03_water.mp3" <(playing)
  "/home/user/music/artist/album/04_fire.mp3"
  "/home/user/music/artist/album/05_earthquake.mp3"

arguments:

  ((no arg)) = do nothing
  (arg) = display matches for (arg) in CURRENT

usage:

  % mifo --match earth
  /home/user/music/artist/album/01_earth.mp3
  /home/user/music/artist/album/05_earthquake.mp3

EOP
    return 0
  }
  if [[ ! -d ${file[base]}/playlists || ! -s ${file[play]} ]] { return 1 }
  if [[ -z $1 ]] { return 1
  } else {
    <${file[play]} | while { read i } {
      if [[ ${#i} != ${#i//$@} ]] {
        print - ${i}
      }
    }
};}

# display current playlist with relative position count, matching arg:
function o_matchn {
  if [[ ! -f ${file[stat]} ]] { return 1 }
  if [[ $1:l == -- ]] {
    << EOP
example:

  "/home/user/music/artist/album/01_earth.mp3"
  "/home/user/music/artist/album/02_wind.mp3"
  "/home/user/music/artist/album/03_water.mp3" <(playing)
  "/home/user/music/artist/album/04_fire.mp3"
  "/home/user/music/artist/album/05_earthquake.mp3"

arguments:

  ((no arg)) = do nothing
  (arg) = display matches for (arg) in CURRENT with count

usage:

  % mifo --matchn earth
  -2 /home/user/music/artist/album/01_earth.mp3
  +2 /home/user/music/artist/album/05_earthquake.mp3

EOP
    return 0
  }
  if [[ ! -d ${file[base]}/playlists || ! -s ${file[play]} ]] { return 1 }
  local n c C S SN x y
  n=${${${(@f)${${(F)"$(<${file[stat]})"}/*[[:cntrl:]]Playing }}[1]}%.}
  <${file[play]} | while { read x } { integer c=$((${c:-0}+1)) ; if [[ ${n} == ${x} ]] { break };}
  C=$c
  if [[ -z $1 ]] { return 1
  } else {
    unset op
    <${file[play]} | while { read i } {
      if [[ $i == $n ]] {
        unset SN op ; SN=0 ; op='+'
        [[ ${+S} == 1 ]] && y="${S:+${S}\\n} 0  ${i}"
      } else {
        if [[ $op == '+' ]] {
          integer SN=$(( ${SN:-0} ${op} 1 ))
          [[ ${+S} == 1 ]] && y="${S:+${S}\\n}${op}${SN}  ${i}"
        } else {
          op='-'
          integer C=$(( ${C} - 1 )) ; SN=$C
          [[ ${+S} == 1 ]] && y="${S:+${S}\\n}-${SN}  ${i}"
      };}
      if [[ ${#i} != ${#i//$@} ]] { print - ${y} }
    };}
    unset SN
}

# display appropriate message and exit erroneously:
function o_err { print - "$@" ; exit 1 }

# display program usage and exit successfully:
function o_help {
  if [[ $1:l == -- ]] {
    << EOP
arguments:

  ((no arg)) = display help message and exit

notes:

  1) You may learn more about each option by typing:
       % mifo OPTION --
     The -- trailing OPTION denotes there's nothing else to parse.
     In this case, it means you will see help specific to --OPTION
  2) You may view more examples and usage details via the manpage:
       % man 1 mifo

EOP
    return 0
  }
  << EOFN
usage: mifo [option] [[arg(s)]]

common options:
  -l,  --load       Load file(s)/dir(s) and restart playback
  -L,  --append     Append file(s)/dir(s) and keep playback
  -b,  --begin      Begin playback; [*list][song][last]
  -t,  --toggle     Toggle playback; [pause,unpause]
  -n,  --next       Play next file; [(integer),keyword]
  -p,  --prev       Play prev file; [(integer),keyword]
  -r,  --repeat     Repeat current file; [on,off,(integer)]
  -x,  --random     Play a random file in current playlist
  -s,  --stop       Stop playback but keep daemon active
  -a,  --announce   Announce current file information
  -o,  --show       Show contents of playlist
  -O,  --shown      Show contents of playlist with count(s)
  -m,  --match      Show matches in current playlist
  -M,  --matchn     Show matches in current.. with count(s)
  -c,  --command    Send MPlayer command to the daemon
  -h,  --help       Display this message and exit

extended options:
  -pa, --add        Add current file to a playlist
  -pr, --remove     Remove current file from a playlist
  -pc, --check      Check if current file is in a playlist
  -ps, --save       Save current playlist as a new playlist
  -pe, --edit       Edit a saved playlist
  -pl, --playlist   Load a saved playlist
  -pp, --printp     Display saved playlists

long options only:
       --instance   Check if daemon is running or not
       --quit       Close daemon, unless already closed
       --init       Start daemon, unless already started

You may also type "OPTION --" for help specific to OPTION.
EOFN
}

## end of FUNCTIONS }}}

if [[ ! ${1} =~ '-h' ]] {
  local -A file
  file[base]=~/.mifo
  file[conf]=~/.mplayer/config
  file[fifo]=${file[base]}/fifo
  file[pgrp]=${file[base]}/pid
  file[stat]=${file[base]}/log
  file[play]=${file[base]}/playlists/CURRENT
  file[fave]=${file[base]}/playlists/exalted.m3u
}

case $1 {
  '-l'|'--load') { i_load ${@:/$1} } always { exec 6<&- } ;;
  '-L'|'--append') { i_load "${$}.append" ${@:/$1} "${$}.append" } always { exec 6<&- } ;;
  '-b'|'--begin') { i_begin ${@:/$1} } always { exec 6<&- } ;;
  '-t'|'--toggle') { i_toggle ${@:/$1} } always { exec 6<&- } ;;
  '-n'|'--next') { i_next ${@:/$1} } always { exec 6<&- } ;;
  '-p'|'--prev') { i_prev ${@:/$1} } always { exec 6<&- } ;;
  '-r'|'--repeat') { i_repeat ${@:/$1} } always { exec 6<&- } ;;
  '-x'|'--random') { i_random ${2} } always { exec 6<&- } ;;
  '-s'|'--stop') { i_stop ${2} } always { exec 6<&- } ;;
  '-a'|'--announce') { o_announce ${@:/$1} } always { exec 6<&- } ;;
  '-o'|'--show') { o_show ${@:/$1} } always { unset PL ; exec 6<&- } ;;
  '-O'|'--shown') { o_shown ${@:/$1} } always { unset PL ; exec 6<&- } ;;
  '-m'|'--match') { o_match ${@:/$1} } always { exec 6<&- } ;;
  '-M'|'--matchn') { o_matchn ${@:/$1} } always { exec 6<&- } ;;
  '-c'|'--command') { i_command ${@:/$1} } always { exec 6<&- } ;;
  '-h'|'--help') { o_help ${2} } always { exec 6<&- } ;;
  '-pa'|'--add') { i_add ${@:/$1} } always { exec 6<&- } ;;
  '-pr'|'--remove') { i_remove ${@:/$1} } always { unset n PL ; exec 6<&- } ;;
  '-pc'|'--check') { i_check ${@:/$1} } always { unset n PL ; exec 6<&- } ;;
  '-ps'|'--save') { i_save ${@:/$1} } always { exec 6<&- } ;;
  '-pe'|'--edit') { i_edit ${@:/$1} } always { exec 6<&- } ;;
  '-pl'|'--playlist') { i_playlist ${@:/$1} } always { unset PL ; exec 6<&- } ;;
  '-pp'|'--printp') { o_printp ${2} } always { exec 6<&- } ;;
  '--instance') { i_active ${2} } always { exec 6<&- } ;;
  '--quit') { i_quit ${@:/$1} } always { exec 6<&- } ;;
  '--init') { i_daemon ${2} } always { exec 6<&- } ;;
  *) exec 6<&- && exit 2 ;;
}
